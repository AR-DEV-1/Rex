#pragma once

#include "rex_directx/utility/dx_util.h"

#include "rex_std/vector.h"
#include "rex_engine/engine/types.h"
#include "rex_std/unordered_map.h"
#include "rex_std/bonus/string.h"

#include "rex_renderer_core/resources/resource.h"

namespace rex
{
	namespace gfx
	{
		struct ShaderPipelineReflection;
		struct BoundResourceReflection;
		struct CBufferReflDesc;



		// Root parameters of a shader define what resources are used within a shader
		// This class is used to hold the root parameters of the entire shader pipeline, to be passed to a root signature for creation
		// the root parameters of this class are filled in by a shader signatures which in turn are generated by shader reflection
		//class DxShaderPipelineParameters
		//{
		//public:
		//	DxShaderPipelineParameters(const ShaderPipelineReflection& shaderPipelineReflection);



		//	const rsl::vector<CD3DX12_ROOT_PARAMETER>& params() const;

		//private:
		//	void add_to_pipeline_parameters(const ShaderSignature& signature, ShaderVisibility shaderVis);
		//	void add_to_view_range(rsl::vector<D3D12_DESCRIPTOR_RANGE>& ranges, s32 startRegister, s32 lastRegister, s32 registerSpace, D3D12_DESCRIPTOR_RANGE_TYPE type);
		//	void add_ranges(rsl::vector<D3D12_DESCRIPTOR_RANGE>& ranges, const rsl::vector<BoundResourceReflection>& resources, D3D12_DESCRIPTOR_RANGE_TYPE type);
		//	//void add_ranges(ViewTableParameter* table, const rsl::vector<CBufferReflDesc>& cbuffers, D3D12_DESCRIPTOR_RANGE_TYPE type);
		//	//void add_ranges(ViewTableParameter* table, const rsl::vector<BoundResourceReflection>& resources, D3D12_DESCRIPTOR_RANGE_TYPE type);

		//	void split_parameters_based_on_register_space(const ShaderPipelineReflection& pipelineRefl);

		//	void split_off_view(ShaderParameter* param);
		//	void split_off_table(ShaderParameter* param);


		//	void split_off_constant(const ShaderPipelineReflection& pipelineRefl, const D3D12_ROOT_PARAMETER& param);
		//	void split_off_cbv(const ShaderPipelineReflection& pipelineRefl, const D3D12_ROOT_PARAMETER& param);
		//	void split_off_srv(const ShaderPipelineReflection& pipelineRefl, const D3D12_ROOT_PARAMETER& param);
		//	void split_off_uav(const ShaderPipelineReflection& pipelineRefl, const D3D12_ROOT_PARAMETER& param);
		//	void split_off_descriptor_table(const ShaderPipelineReflection& pipelineRefl, const D3D12_ROOT_PARAMETER& param);

		//	struct SplittedConstantBuffers
		//	{
		//		rsl::vector<CBufferReflDesc> material_cbs;
		//		rsl::vector<CBufferReflDesc> renderpass_cbs;
		//	};
		//	SplittedConstantBuffers split_constant_buffers(const rsl::vector<CBufferReflDesc> constantBuffers);

		//	struct SplittedResources
		//	{
		//		rsl::vector<BoundResourceReflection> material_resources;
		//		rsl::vector<BoundResourceReflection> renderpass_resources;
		//	};
		//	SplittedResources split_resources(const rsl::vector<BoundResourceReflection> resources);

		//	rsl::vector<ViewRange> create_cb_view_ranges(const rsl::vector<CBufferReflDesc>& cbs, rsl::unordered_map<rsl::string, s32>& nameToIdxMap);
		//	rsl::vector<ViewRange> create_resource_view_ranges(const rsl::vector<BoundResourceReflection>& resources, rsl::unordered_map<rsl::string, s32>& nameToIdxMap, DescriptorRangeType type);

		//	void process_shader(const ShaderSignature& signature, ShaderVisibility visibility);
		//private:

		//	rsl::vector<ViewTable> m_view_tables;
		//	rsl::unordered_map<rsl::string, s32> m_material_param_name_to_idx;
		//	rsl::unordered_map<rsl::string, s32> m_renderpass_param_name_to_idx;




		//	// Cached root signature parameters
		//	rsl::vector<CD3DX12_ROOT_PARAMETER> m_root_parameters;

		//	// The view ranges need to stick around as they don't get copied into the root signature directly
		//	// Instead a pointer to them is given, so if we'd allocate them locally, they'd be destroyed by the time they're used
		//	rsl::vector<D3D12_DESCRIPTOR_RANGE> m_textures_and_samplers;
		//};

		struct DxShaderPipelineParameters2
		{
			rsl::vector<CD3DX12_ROOT_PARAMETER> root_parameters;
			rsl::vector<rsl::vector<D3D12_DESCRIPTOR_RANGE>> ranges;

			rsl::vector<D3D12_DESCRIPTOR_RANGE> material_ranges;
			rsl::vector<D3D12_DESCRIPTOR_RANGE> renderpass_ranges;
		};
	}
}
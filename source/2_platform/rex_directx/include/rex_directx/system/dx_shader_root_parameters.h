#pragma once

#include "rex_directx/utility/dx_util.h"

#include "rex_std/vector.h"
#include "rex_engine/engine/types.h"
#include "rex_std/unordered_map.h"
#include "rex_std/bonus/string.h"

namespace rex
{
	namespace gfx
	{
		struct ShaderPipelineReflection;
		struct BoundResourceReflection;

		// Root parameters of a shader define what resources are used within a shader
		// This class is used to hold the root parameters of the entire shader pipeline, to be passed to a root signature for creation
		// the root parameters of this class are filled in by a shader signatures which in turn are generated by shader reflection
		class DxShaderPipelineParameters
		{
		public:
			DxShaderPipelineParameters(const ShaderPipelineReflection& shaderPipelineReflection);

			const rsl::vector<CD3DX12_ROOT_PARAMETER>& params() const;

		private:
			void add_to_pipeline_parameters(const ShaderSignature& signature, ShaderVisibility shaderVis);
			void add_to_view_range(rsl::vector<D3D12_DESCRIPTOR_RANGE>& ranges, s32 startRegister, s32 lastRegister, D3D12_DESCRIPTOR_RANGE_TYPE type);
			void add_ranges(rsl::vector<D3D12_DESCRIPTOR_RANGE>& ranges, const rsl::vector<BoundResourceReflection>& resources, D3D12_DESCRIPTOR_RANGE_TYPE type);

		private:
			// Cached root signature parameters
			rsl::vector<CD3DX12_ROOT_PARAMETER> m_root_parameters;

			// The view ranges need to stick around as they don't get copied into the root signature directly
			// Instead a pointer to them is given, so if we'd allocate them locally, they'd be destroyed by the time they're used
			rsl::vector<D3D12_DESCRIPTOR_RANGE> m_texture_ranges;
			rsl::vector<D3D12_DESCRIPTOR_RANGE> m_sampler_ranges;
		};
	}
}
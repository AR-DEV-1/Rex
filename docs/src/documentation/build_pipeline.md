# Build Pipeline

## Introduction
Rex entire building pipeline, going from setting up the initial setup to the actual build process, generation and testing is written in python. This is done to allow quick iteration which would be more of hassle in C# or C++.

The build pipeline scripts is only supposed to launch multiple intermediate steps and not do much work on its own.

## Setup
To setup Rex Engine after an initial clone from [github](https://github.com/Dyronix/Rex) run `_setup.py`

_setup.py will read some configuration files, looking for dependencies needed for by Rex Engine based on your platform (eg. Windows -> Windows SDK).

If these dependencies aren't found, it'll download these over the network and cache their install paths.

Additionally, Rex Engine has a dependency on 2 smaller Rex modules, namely Rex Stl and Rex Py. like the other dependencies, these are downloaded as well, but if you want to specifically update these as well you must pass either `-update_rsl` or `-update_rexpy` to update rex stl or rex py respectively.

The reason these are not marked submodules at the moment is because they regularly get updates which is too much of a hassle to get properly working with git over multiple branches.

Some Examples:
```sh
# Will do an initial setup.
# Updating non-cached paths and cached paths that no longer exist
py _setup.py

# Same as initial setup but will explicitly update rsl as well.
py _setup.py -update_rsl

# Same as initial setup but will explicitly update rexpy as well.
py _setup.py -update_rexpy

# Same as initial setup but will explicitly update rsl and rexpy as well.
py _setup.py -update_rsl -update_rexpy
```

## Generation
Rex Engine uses a custom [Sharpmake](https://github.com/RisingLiberty/Sharpmake) implementation to generate ninja files. All you have to do is call `_generate.py`. A visual studio solution generation is also supported for debugging purposes. Such a solution can be generated by passing in `-vs` argument to `_generate.py`

Sharpmake is a make tool written in C# and who's scripts are also written in C#. Rex's Sharpmake version is extended to also support ninja file generation as well unity build support with visual studio

Sharpmake was chosen over other make tools due to it being easier to debug and extend. Additionally you can run custom code more easily before and after generation as everything is in C#.

Some Examples:
```sh
# Generate ninja files for the rex engine, these will be used by _build.py
py _generate.py

# Generate visual studio solution for the rex engine
py _generate.py -vs
```

## Building
Rex Engine uses ninja files to build its engine. The reason ninja was chosen over msbuild (or other native tool chains) is because of its speed (it can build all configurations faster than msbuild). Addition to speed, it's also cross platform and we don't have a custom toolchain for every platform, instead we have 1 toolchain that works for all platforms supported by Rex Engine.

This only works because Rex also has a custom version of [Ninja](https://github.com/RisingLiberty/ninja) with a small tweak to allow duplicate includes in ninja files.

Additionally a postbuild is also fired for all first party project (and Rex written third party projects like rsl) which launches clang-tidy and clang-format auto fixing a limited set of checks.

to build a specific project, configuration with a certain compiler, you call the `_build.py` script with the following arguments:
- project - This is the project you want to build
- config - This is the configuration you want to build for
- comp - This is the compiler you want to use to build your project

Some additional flags are also available.
- clean - this performs a clean build, meaning it'll clear existing intermediate files and launch a build afterwards
- project_only - this only builds the project without its dependencies and therefore won't perform any linking.

Special compilation flags [Testing](#Testing)
- coverage - this builds the code with code coverage enabled
- asan - this build the code with address sanitizer enabled
- ubsan - this builds the code with undefined behvaior sanitizer enabled
- fuzzy - this builds the code with fuzzy testing enabled

Some Examples:
```sh
# Builds regina project and its dependencies in debug mode using msvc compiler
py _build.py -project=regina -config=debug -comp=msvc

# Builds only regina project in debug mode using msvc compiler without linking
py _build.py -project=regina -config=debug -comp=msvc -project_only

# Cleans all regina and its depedencies' intermediate files and then performs a build afterwards
py _build.py -project=regina -config=debug -comp=msvc -clean

# Cleans only regina intermediate files and performs a build afterwards, without linking
py _build.py -project=regina -config=debug -comp=msvc -project_only -clean
```

## Testing
Rex Engine supports many different kind of tests for optimal testing which can all be fired from `_test.py`.

To run all tests, pass in `-all` to `_test.py`

The following tests are supported for Rex Engine

### include-what-you-use
flag: `-iwyu`

A tool providing directly hooked into the compiler to scan for includes that aren't needed and could be replaced with a forward declaration or removed all together.
### clang-tidy
flag: `-clang_tidy`

A static analyser directly hooked into the compiler to scan for possible design problems, readability issues or bugs. None of the checks in here will auto fix themselves and all warnings are treated as error.
### Unit tests
flag: `-unity_tests`

Every big framework should have its own unit tests so of course rex has it own as well. We use catch2 for our unit tests, these unit tests can be added to the visual studio solution by passing in `-generate_unittests` to `_generate.py`
### Coverage
flag: `-coverage`

Code coverage is a good way to verify all your code is executed and you don't have any deadcode anywhere in your codebase. With a big framework it becomes tricky to spot which code is still active and which code can be removed, code coverage is implemented to resolve and quickly find dead code in your code base.
With this flag, unit tests will run with coverage enabled. A coverage html report is auto generated after each run allowing you to inspect which code has been executed and which code hasn't.
### Address Sanitizer
flag: `-asan`

Address sanitizer is a flag added to the compiler to add extra code with memory access instructions. This is useful to track down memory issues you might not even know you have. With this flag, unit tests will be run with asan enabled, tracking down if you have any memory bugs in your code.
### Undefined Behavior Sanitizer
flag: `-ubsan`

Undefined behavior sanitizer is a similar flag as address sanitizer but instead looking for memory bugs, it looks for undefined behavior in your code. with this flag, unit tests will be run with ubsan enabled, tracking down if you have any undefined behavior in your code. 
### Fuzzy Testing
flag: `-fuzzy`

Fuzzy Testing is a special kind of testing where the program will pass in a new buffer with random length and random data to your program over and over again. It's up to you to then cast this data into some result and run it on your code, checking if you're can handle random (and wrong input). it's highly recommended to enable this with asan and ubsan enabled as well, checking if you're code doesn't run into any memory or undefined issues.
With this flag enabled, you'll run the fuzzy tests for the Rex Engine.

Some Examples:
```sh
# This will run all the test of Rex Engine
py _test.py -all

# This will run include-what-you-use on the Rex codebase
py _test.py -iwyu

# This will run include-what-you-use and clang-tidy on the Rex codebase
py _test.py -iwyu -clang_tidy

# This will run the unit tests of the Rex codebase
py _test.py -unit_tests

# This will run address sanitizer and undefined behavior on the unit tests of Rex codebase
py _test.py -asan -ubsan

# This will run the fuzzy tests and unit tests of the Rex codebase
py _test.py -fuzzy -unit_tests

```
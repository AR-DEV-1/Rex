// ============================================ 
//
// REX - BUILD SYSTEM
//
// Author: Nick De Breuck
// Twitter: @nick_debreuck
// 
// File: main.sharpmake.cs
// Copyright (c) Nick De Breuck 2022
//
// ============================================

using System.IO;
using Sharpmake;

[module: Sharpmake.Include("globals.sharpmake.cs")]
[module: Sharpmake.Include("target.sharpmake.cs")]
[module: Sharpmake.Include("config.sharpmake.cs")]

// Represents the project that will be generated by Sharpmake and that contains
// the sample C++ code.
public class BaseProject : Project
{
  protected string IncludeFolder = "";

  public BaseProject() : base(typeof(RexTarget), typeof(RexConfiguration))
  {
  }

  [Configure]
  public virtual void Configure(RexConfiguration conf, RexTarget target)
  {
    conf.Name = target.Config.ToString().ToLower();
    conf.ProjectPath = Path.Combine(Globals.Root, ".rex", "build", target.DevEnv.ToString(), Name);
    conf.IntermediatePath = Path.Combine(conf.ProjectPath, "intermediate", conf.Name, target.Compiler.ToString());
    conf.TargetPath = Path.Combine(conf.ProjectPath, "bin", conf.Name);
    conf.UseRelativePdbPath = false;
    conf.LinkerPdbFilePath = Path.Combine(conf.TargetPath, $"{Name}_{conf.Name}_{target.Compiler}{conf.LinkerPdbSuffix}.pdb");
    conf.CompilerPdbFilePath = Path.Combine(conf.TargetPath, $"{Name}_{conf.Name}_{target.Compiler}{conf.CompilerPdbSuffix}.pdb");

    //conf.IncludePaths.Add(IncludeFolder);
    conf.IncludePaths.Add(Path.Combine(IncludeFolder, ".."));

    conf.disable_exceptions();

    conf.use_general_options();
    conf.use_compiler_options();
    conf.use_linker_options();

    switch (target.Optimization)
    {
      case Optimization.NoOpt:
        conf.Options.Add(Options.Vc.General.DebugInformation.ProgramDatabase);
        conf.disable_optimization();
        break;
      case Optimization.FullOptWithPdb:
        conf.Options.Add(Options.Vc.General.DebugInformation.ProgramDatabase);
        conf.enable_optimization();
        conf.Options.Add(Options.Vc.Linker.LinkTimeCodeGeneration.Default);      // To fix linker warning
        conf.Options.Add(Options.Vc.Compiler.OmitFramePointers.Disable);         // Disable so we can have a stack trace
        break;
      case Optimization.FullOpt:
        conf.Options.Add(Options.Vc.General.DebugInformation.Disable);
        conf.Options.Add(Options.Vc.General.WholeProgramOptimization.Optimize);
        conf.enable_optimization();
        break;
    }

    switch (target.Config)
    {
      case Config.assert:
        break;
      case Config.debug:
        conf.add_public_define("REX_ENABLE_LOGGING");
        conf.add_public_define("REX_ENABLE_HR_CALL");
        conf.add_public_define("REX_ENABLE_WIN_CALL");
        break;
      case Config.debug_opt:
        conf.add_public_define("REX_ENABLE_LOGGING");
        conf.add_public_define("REX_ENABLE_HR_CALL");
        conf.add_public_define("REX_ENABLE_WIN_CALL");
        break;
      case Config.release:
        break;
      case Config.tests:
        break;
      default:
        break;
    }
  }

  public override bool ResolveFilterPath(string relativePath, out string filterPath)
  {
    string absolutePath = Path.GetFullPath(Path.Combine(SourceRootPath, relativePath)).ToLower();

    if (absolutePath.Contains(IncludeFolder.ToLower()))
    {
      filterPath = Util.PathGetRelative(IncludeFolder, absolutePath);
      return true;
    }

    filterPath = null;
    return false;
  }

}

public class ThirdPartyProject : BaseProject
{
  public ThirdPartyProject() : base()
  { }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.SolutionFolder = "0_extern";
  }
}

public class EngineProject : BaseProject
{
  public EngineProject() : base()
  { }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.SolutionFolder = "1_engine";
  }
}

public class PlatformProject : BaseProject
{
  public PlatformProject() : base()
  { }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.SolutionFolder = "2_platform";
  }
}

public class AppLibrariesProject : BaseProject
{
  public AppLibrariesProject() : base()
  { }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.SolutionFolder = "3_app_libs";
  }
}

public class ToolsProject : BaseProject
{
  public ToolsProject() : base()
  { }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.SolutionFolder = "5_tools";
  }
}

[Generate]
public class RexStandardLibrary : ThirdPartyProject
{
  public RexStandardLibrary() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexStd";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."

    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "0_extern", "rex_std");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "0_extern", "rex_std");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;

    switch (conf.Platform)
    {
      case Platform.win32:
        conf.add_public_define("REX_PLATFORM_X86");
        break;
      case Platform.win64:
        conf.add_public_define("REX_PLATFORM_X64");
        break;
      default:
        break;
    }
  }
}

[Generate]
public class RexStandardExtraLibrary : ThirdPartyProject
{
  public RexStandardExtraLibrary() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexStdExtra";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."

    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "0_extern", "rex_std_extra");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "0_extern", "rex_std_extra");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;

    conf.add_dependency<RexStandardLibrary>(target);
  }
}

[Generate]
public class RexEngine : EngineProject
{
  public RexEngine() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexEngine";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "1_engine", "rex_engine");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "1_engine", "rex_engine");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;
    conf.IncludePaths.Add(IncludeFolder);

    conf.add_dependency<RexStandardExtraLibrary>(target);
  }
}

[Generate]
public class RexMemory : EngineProject
{
  public RexMemory() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexMemory";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "0_extern", "rex_std");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "1_engine", "rex_memory");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;
    conf.IncludePaths.Add(IncludeFolder);

    conf.add_dependency<RexStandardExtraLibrary>(target);
  }
}

[Generate]
public class RexWindows : PlatformProject
{
  public RexWindows() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexWindows";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "2_platform", "rex_windows");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "2_platform", "rex_windows");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;
    conf.IncludePaths.Add(IncludeFolder);

    conf.add_dependency<RexEngine>(target);
    conf.add_dependency<RexMemory>(target);

    conf.add_public_define("REX_PLATFORM_WINDOWS");
  }
}

[Generate]
public class RexApplicationCore : AppLibrariesProject
{
  public RexApplicationCore() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexApplicationCore";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "3_app_libraries", "rex_application_core");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "3_app_libraries", "rex_application_core");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;
    conf.IncludePaths.Add(IncludeFolder);

    conf.add_dependency<RexWindows>(target);
  }
}

[Generate]
public class Regina : ToolsProject
{
  public Regina() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "Regina";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "src", "5_tools", "regina");
    IncludeFolder = Path.Combine(Globals.SourceRoot, "include", "5_tools", "regina");
    AdditionalSourceRootPaths.Add(IncludeFolder);

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);

    CustomFilterMapping.Add(IncludeFolder, "");
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Exe;
    conf.IncludePaths.Add(IncludeFolder);

    conf.add_dependency<RexApplicationCore>(target);
  }
}

// Represents the solution that will be generated and that will contain the
// project with the sample code.
[Generate]
public class MainSolution : Solution
{
  public MainSolution() : base(typeof(RexTarget))
  {
    // The name of the solution.
    Name = "rex";

    // As with the project, define which target this solution builds for.
    // It's usually the same thing.
    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  // Configure for all 4 generated targets. Note that the type of the
  // configuration object is of type Solution.Configuration this time.
  // (Instead of Project.Configuration.)
  [Configure]
  public void Configure(Configuration conf, RexTarget target)
  {
    // Puts the generated solution in the root folder.
    conf.SolutionPath = Globals.Root;

    // Adds the project described by BasicsProject into the solution.
    // Note that this is done in the configuration, so you can generate
    // solutions that contain different projects based on their target.
    //
    // You could, for example, exclude a project that only supports 64-bit
    // from the 32-bit targets.
    conf.AddProject<Regina>(target);
  }
}

public static class Main
{
  [Sharpmake.Main]
  public static void SharpmakeMain(Arguments arguments)
  {
    Globals.Init();

    InitializeSharpmake();

    // Tells Sharpmake to generate the solution described by MainSolution.
    arguments.Generate<MainSolution>();
  }

  private static void InitializeSharpmake()
  {
    KitsRootPaths.InitializeForNinja();

    // Initialize Visual Studio settings
    KitsRootPaths.SetUseKitsRootForDevEnv(DevEnv.vs2019, KitsRootEnum.KitsRoot10, Options.Vc.General.WindowsTargetPlatformVersion.v10_0_19041_0);
  }
}
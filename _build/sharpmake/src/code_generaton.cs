using System.Collections.Generic;
using System.Text.Json;
using System.IO;
using Sharpmake;
using System.Text;

public class CodeGeneration
{
  static private Dictionary<string, EnumGenerationSettings> EnumsToAutoGenerate = new Dictionary<string, EnumGenerationSettings>();
  static private Dictionary<string, ArrayGenerationSettings> ArraysToAutoGenerate = new Dictionary<string, ArrayGenerationSettings>();

  public static void ReadGenerationFile(string projectName, string filePath)
  {
    string json_blob = File.ReadAllText(filePath);
    Dictionary<string, JsonDocument> config = JsonSerializer.Deserialize<Dictionary<string, JsonDocument>>(json_blob);

    foreach (string key in config.Keys)
    {
      JsonDocument doc = config[key];
      string typename = doc.RootElement.GetProperty("Type").GetString();
      JsonElement content = doc.RootElement.GetProperty("Content");
      Process(projectName, key, typename, content, filePath);
    }
  }

  public static void Generate()
  {
    foreach (EnumGenerationSettings enum_gen_settings in EnumsToAutoGenerate.Values)
    {
      WriteAutoGeneratedEnumToFile(enum_gen_settings.ClassName, enum_gen_settings.ProjectToEnumValues, enum_gen_settings.Filepath, enum_gen_settings.ProjectToGenerationFile);
    }

    foreach (ArrayGenerationSettings array_gen_settings in ArraysToAutoGenerate.Values)
    {
      WriteAutoGeneratedArrayToFile(array_gen_settings.ElementType, array_gen_settings.Name, array_gen_settings.Includes, array_gen_settings.ProjectToArrayValues, array_gen_settings.Filepath, array_gen_settings.ProjectToGenerationFile);
    }
  }
  private static void Process(string projectName, string key, string typename, JsonElement content, string generationFilePath)
  {
    switch (typename)
    {
      case "Enum": ProcessEnum(projectName, key, content, generationFilePath); break;
      case "Array": ProcessArray(projectName, key, content, generationFilePath); break;
      default:
        break;
    }
  }

  private static void ProcessEnum(string projectName, string key, JsonElement content, string generationFilePath)
  {
    EnumGenerationConfig enum_config = JsonSerializer.Deserialize<EnumGenerationConfig>(content.ToString());

    if (!EnumsToAutoGenerate.ContainsKey(key))
    {
      EnumsToAutoGenerate.Add(key, new EnumGenerationSettings());

      // we use the config settings of the first enum we encounter, all others need to match this
      EnumsToAutoGenerate[key].ClassName = enum_config.ClassName;
      EnumsToAutoGenerate[key].Filepath = enum_config.Filepath;
    }
    else
    {
      EnumGenerationSettings enum_gen_settings = EnumsToAutoGenerate[key];

      // class names and filenames should be consistent among all generation files
      if (enum_gen_settings.ClassName != enum_config.ClassName)
      {
        throw new Error($"Enum generation error - unexpected classname: '{enum_config.ClassName}' - expected: {enum_gen_settings.ClassName} for projectName: {projectName}");
      }

      if (enum_gen_settings.Filepath != enum_config.Filepath)
      {
        throw new Error($"Enum generation error - unexpected filepath: '{enum_config.Filepath}' - expected: {enum_gen_settings.Filepath} for projectName: {projectName}");
      }
    }

    EnumGenerationSettings settings = EnumsToAutoGenerate[key];
    settings.ProjectToEnumValues.Add(projectName, enum_config.Values);
    settings.ProjectToGenerationFile.Add(projectName, generationFilePath);
  }

  private static void ProcessArray(string projectName, string key, JsonElement content, string generationFilePath)
  {
    ArrayGenerationConfig enum_config = JsonSerializer.Deserialize<ArrayGenerationConfig>(content.ToString());

    if (!ArraysToAutoGenerate.ContainsKey(key))
    {
      ArraysToAutoGenerate.Add(key, new ArrayGenerationSettings());

      // we use the config settings of the first enum we encounter, all others need to match this
      ArraysToAutoGenerate[key].ElementType = enum_config.ElementType;
      ArraysToAutoGenerate[key].Name = enum_config.Name;
      ArraysToAutoGenerate[key].Includes = enum_config.Includes;
      ArraysToAutoGenerate[key].Filepath = enum_config.Filepath;
    }
    else
    {
      ArrayGenerationSettings array_gen_settings = ArraysToAutoGenerate[key];

      // element types, class types includes, and filepaths should be consistent among all generation files
      if (array_gen_settings.ElementType != enum_config.ElementType)
      {
        throw new Error($"Array generation error - unexpected element type: '{enum_config.ElementType}' - expected: {array_gen_settings.ElementType} for projectName: {projectName}");
      }

      if (array_gen_settings.Name != enum_config.Name)
      {
        throw new Error($"Array generation error - unexpected name: '{enum_config.Name}' - expected: {array_gen_settings.Name} for projectName: {projectName}");
      }

      if (array_gen_settings.Filepath != enum_config.Filepath)
      {
        throw new Error($"Array generation error - unexpected filepath: '{enum_config.Filepath}' - expected: {array_gen_settings.Filepath} for projectName: {projectName}");
      }
    }

    ArrayGenerationSettings settings = ArraysToAutoGenerate[key];
    settings.ProjectToArrayValues.Add(projectName, enum_config.Values);
    settings.ProjectToGenerationFile.Add(projectName, generationFilePath);
  }

  private static void WriteAutoGeneratedEnumToFile(string className, Dictionary<string, List<string>> enumValues, string filename, Dictionary<string, string> projectToGenerationFile)
  {
    StringBuilder sb = new StringBuilder();
    WriteCustomGenerationHeader(sb);
    WriteBeginNamespace(sb);

    sb.AppendLine($"  enum class {className}");
    sb.AppendLine("  {");

    foreach (var project_vals in enumValues)
    {
      sb.AppendLine($"    // {className} values for {project_vals.Key}");
      sb.AppendLine($"    // generated from {projectToGenerationFile[project_vals.Key]}");

      foreach (string val in project_vals.Value)
      {
        sb.AppendLine($"    {val},");
      }
      sb.AppendLine(" ");
    }

    sb.AppendLine("  };");

    WriteEndNamespace(sb);
    WriteCustomGenerationFooter(sb);
    WriteToDisk(sb, Path.Combine(Globals.SourceRoot, filename));
  }

  private static void WriteAutoGeneratedArrayToFile(string elementType, string name, List<string> includes, Dictionary<string, List<string>> arrayValues, string filename, Dictionary<string, string> projectToGenrationFile)
  {
    StringBuilder sb = new StringBuilder();

    WriteCustomGenerationHeader(sb);

    foreach (string include in includes)
    {
      sb.AppendLine($"#include \"{include}\"");
    }

    sb.AppendLine($"#include \"rex_std/array.h\"");

    WriteBeginNamespace(sb);

    sb.AppendLine($"  inline rsl::array {name} = ");
    sb.AppendLine("  {");

    foreach (var project_vals in arrayValues)
    {
      sb.AppendLine($"    // {elementType} values for {project_vals.Key}");
      sb.AppendLine($"    // generated from {projectToGenrationFile[project_vals.Key]}");

      foreach (string val in project_vals.Value)
      {
        sb.AppendLine($"    {elementType}{{ {val}, \"{project_vals.Key}\" }},");
      }
      sb.AppendLine(" ");
    }

    sb.AppendLine("  };");

    WriteEndNamespace(sb);
    WriteCustomGenerationFooter(sb);
    WriteToDisk(sb, Path.Combine(Globals.SourceRoot, filename));
  }

  private static void WriteCustomGenerationHeader(StringBuilder sb)
  {
    sb.AppendLine("#pragma once");
    sb.AppendLine("");
    sb.AppendLine("// DON'T EDIT - This file is auto generated by sharpmake");
    sb.AppendLine("// NOLINTBEGIN");
    sb.AppendLine("");
  }

  private static void WriteBeginNamespace(StringBuilder sb, string namespaceName = "rex")
  {
    sb.AppendLine($"namespace {namespaceName}");
    sb.AppendLine($"{{");
  }

  private static void WriteCustomGenerationFooter(StringBuilder sb)
  { }

  private static void WriteEndNamespace(StringBuilder sb, string namespaceName = "rex")
  {
    sb.AppendLine($"}} // namespace {namespaceName}");
    sb.AppendLine($"// NOLINTEND");
  }

  private static void WriteToDisk(StringBuilder sb, string filePath)
  {
    FileStream stream = File.Open(filePath, FileMode.Truncate);

    byte[] bytes = Encoding.ASCII.GetBytes(sb.ToString());
    stream.Write(bytes, 0, sb.Length);
    stream.Close();

  }
}